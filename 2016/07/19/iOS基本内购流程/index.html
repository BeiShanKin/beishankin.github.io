<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Yu Song">
  <!-- Open Graph Data -->
  <meta property="og:title" content="iOS基本内购流程"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="登高望远"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="登高望远" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>登高望远</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/blog/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/blog/css/style.dark.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/blog//img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">iOS基本内购流程</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/blog/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/blog/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/beishankin">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:syiosengineer1992@gmail.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Yu Song</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2016-07-19</span>
            <span class="time">15:47:22</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/blog/categories/iOS/">iOS</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/blog/tags/iOS/">#iOS</a> <a class="tag" href="/blog/tags/内购/">#内购</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>这也是一边移植老文，文章中还有不少纰漏，还有一些应该放出的代码也没有放出，一直拖到今天。以后如果有再用到内购的时候，我想我会把这篇文章补全为iOS内购全解。</p>
<a id="more"></a>
<p>iOS的内购流程如下</p>
<ol>
<li>通过产品ID获取产品信息列表</li>
<li>添加监听</li>
<li>把产品包装成SKPayment（支付）发送给苹果服务器</li>
<li>苹果服务器购买成功后会回调监听方法，根据苹果服务器返回信息判断是否购买成功。</li>
<li>购买失败或已经购买过该商品则注销交易。如果购买成功，此时可以向自家服务器发送购买成功的消息，并通过后台向苹果服务器发送验证，然后注销交易。</li>
</ol>
<h4 id="一般而言，这就是iOS内购的基本过程，看似很简单，但是其实实际操作起来，还是比较麻烦的，因为要考虑到各种意外情况。"><a href="#一般而言，这就是iOS内购的基本过程，看似很简单，但是其实实际操作起来，还是比较麻烦的，因为要考虑到各种意外情况。" class="headerlink" title="一般而言，这就是iOS内购的基本过程，看似很简单，但是其实实际操作起来，还是比较麻烦的，因为要考虑到各种意外情况。"></a>一般而言，这就是iOS内购的基本过程，看似很简单，但是其实实际操作起来，还是比较麻烦的，因为要考虑到各种意外情况。</h4><p>下面讲一讲iOS内购的具体过程<br>1、获取产品信息列表<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="built_in">SKPaymentQueue</span> canMakePayments]) &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *IDSet = [<span class="built_in">NSSet</span> setWithArray:proID];</span><br><span class="line">    <span class="built_in">SKProductsRequest</span> *productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] initWithProductIdentifiers:IDSet];</span><br><span class="line">    productsRequest.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [productsRequest start];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"用户禁止付费"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中的proID就是装有你在开发者后台创建内购产品时输入的产品ID的NSArray。<br>delegate是指SKProductsRequestDelegate<br>首先判断用户是否禁止付费，如果没有禁止付费，就想苹果服务器请求产品信息。<br>请求的信息会在SKProductsRequestDelegate的方法中返回<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)productsRequest:(<span class="built_in">SKProductsRequest</span> *)request didReceiveResponse:(<span class="built_in">SKProductsResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>, response.products.count);</span><br><span class="line">    <span class="built_in">NSArray</span> *myProducts = response.products;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == myProducts.count) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"无法获取产品信息列表"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.products = [myProducts sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span>  _Nonnull obj1, <span class="keyword">id</span>  _Nonnull obj2) &#123;</span><br><span class="line">            <span class="built_in">SKProduct</span> *pro1 = (<span class="built_in">SKProduct</span> *)obj1;</span><br><span class="line">            <span class="built_in">SKProduct</span> *pro2 = (<span class="built_in">SKProduct</span> *)obj2;</span><br><span class="line">            <span class="keyword">return</span> pro1.price.integerValue &lt; pro2.price.integerValue ? <span class="built_in">NSOrderedAscending</span> : <span class="built_in">NSOrderedDescending</span>;</span><br><span class="line">        &#125;];;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">SKProduct</span> *pro <span class="keyword">in</span> myProducts) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [pro localizedTitle]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [pro localizedDescription]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [pro price]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [pro.priceLocale objectForKey:<span class="built_in">NSLocaleCurrencySymbol</span>]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [pro.priceLocale objectForKey:<span class="built_in">NSLocaleCurrencyCode</span>]);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [pro productIdentifier]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拿到产品信息以后可以进行排序处理，因为请求的时候发送的产品ID是装在一个NSSet中的，所以返回的产品信息也是乱序的，这里需要注意一下。</p>
<p>2、内购监听<br>拿到产品信息以后要设置监听，因为当你点击购买和购买后苹果服务器会通过监听方法通知应用。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startObserver &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isObserver) &#123;</span><br><span class="line">        [[<span class="built_in">SKPaymentQueue</span> defaultQueue] addTransactionObserver:<span class="keyword">self</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"开始监听 ------ 内购"</span>);</span><br><span class="line">        <span class="keyword">self</span>.isObserver = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopObserver &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isObserver) &#123;</span><br><span class="line">        [[<span class="built_in">SKPaymentQueue</span> defaultQueue] removeTransactionObserver:<span class="keyword">self</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"移除监听 ------ 内购"</span>);</span><br><span class="line">        <span class="keyword">self</span>.isObserver = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>监听方法和移除监听的方法一起送上，isObserver是一个判断是否已经监听的BOOL数据。<br>我的建议是将监听方法和移除监听的方法都在AppDelegate中执行。当App启动时（<br>application didFinishLaunchingWithOptions）开始监听，当App被关闭时（applicationWillTerminate:）移除监听。至于原因，后面会提到。</p>
<p>3、实现监听方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)paymentQueue:(<span class="built_in">SKPaymentQueue</span> *)queue updatedTransactions:(<span class="built_in">NSArray</span>&lt;<span class="built_in">SKPaymentTransaction</span> *&gt; *)transactions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了几次这个方法？"</span>);</span><br><span class="line">    <span class="built_in">SKPaymentTransaction</span> *transaction = transactions.lastObject;</span><br><span class="line">    <span class="keyword">switch</span> (transaction.transactionState) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStatePurchased</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"购买完成,向自己的服务器验证 ---- %@"</span>, transaction.payment.applicationUsername);</span><br><span class="line">            <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[[<span class="built_in">NSBundle</span> mainBundle] appStoreReceiptURL] path]];</span><br><span class="line">            <span class="built_in">NSString</span> *receipt = [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">            [<span class="keyword">self</span> buySuccessWithReceipt:receipt transaction:transaction];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStateFailed</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"交易失败"</span>);</span><br><span class="line">            [[<span class="built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:transaction];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStateRestored</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"已经购买过该商品"</span>);</span><br><span class="line">            [[<span class="built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:transaction];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">SKPaymentTransactionStatePurchasing</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"商品添加进列表"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"这是什么情况啊？"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishTransaction:就是注销方法，如果不注销会出现报错和苹果服务器不停的通知监听方法等等情况。总之，记住要注销交易。<br>有的同学可能会疑惑，transaction.payment.applicationUsername中的这个applicationUsername属性是干嘛的，先不要急，关于这个属性我们会在后面提到，现在先记住这个点就好。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:[[[<span class="built_in">NSBundle</span> mainBundle] appStoreReceiptURL] path]]; </span><br><span class="line"><span class="built_in">NSString</span> *receipt = [data base64EncodedStringWithOptions:<span class="number">0</span>];</span><br><span class="line">[<span class="keyword">self</span> buySuccessWithReceipt:receipt transaction:transaction];</span><br></pre></td></tr></table></figure>
<p>关于这三句，要注意，receipt是刚才交易的清单，如果后台需要进行二次验证，需要用到这个数据。<br>至于最后一句，则是购买成功后向自家的服务器发送的请求。</p>
<h4 id="发送内购请求"><a href="#发送内购请求" class="headerlink" title="发送内购请求"></a>发送内购请求</h4><p>完成上面的代码后，就可以进行发送内购请求的部分啦</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SKMutablePayment</span> *payment = [<span class="built_in">SKMutablePayment</span> paymentWithProduct:product];</span><br><span class="line">payment.applicationUsername = [AppManager sharedInstance].userId.stringValue;</span><br><span class="line">[[<span class="built_in">SKPaymentQueue</span> defaultQueue] addPayment:payment];</span><br></pre></td></tr></table></figure>
<p>内购请求很简单，就是用请求道的产品信息SKProduct创建一个“内购支付”SKPayment，然后添加进支付队列。</p>
<h4 id="以上就是iOS内购的全部核心代码。接下来要讲的，就是一些内购中可能出现的坑和如何跳过这些坑。"><a href="#以上就是iOS内购的全部核心代码。接下来要讲的，就是一些内购中可能出现的坑和如何跳过这些坑。" class="headerlink" title="以上就是iOS内购的全部核心代码。接下来要讲的，就是一些内购中可能出现的坑和如何跳过这些坑。"></a>以上就是iOS内购的全部核心代码。接下来要讲的，就是一些内购中可能出现的坑和如何跳过这些坑。</h4><p>细心的同学应该已经发现，在发送内购请求的代码部分，我们又一次见到了applicationUsername这个属性，并将用户的id赋值给了它，那么，这是用来干什么的呢？<br>答案是：在某些极端情况下，可能出现在发送内购请求的用户和内购成功后通知自家后台的用户可能不是同一个用户的情况（真是奇葩的用户。。。。但是没办法，用户就是上帝嘛。。。）这种情况下，为payment绑定一个appUsername就可以让这次payment有一个固定的发起者，这样当这次payment在苹果后台支付成功后，我们就可以通过监听的回调，将这个发起者的唯一标识符上传给自家后台，使得这次购买能找到一个合适的主人。就算用户在购买的过程中切换账号或者退出，也能够让这次充值验证成功。</p>
<p>既然说到了极端情况，那么我们不如更进一步，让情况更极端一点，那就是当购买请求发送后，直到向苹果后台购买成功的这段时间，如果程序崩溃了！或者程序被用户关闭了！怎么办？！<br>这种情况下，我们的App自然也就无法进行监听的回调，自然也就无法把购买成功的消息发送给自家后台，用户也就拿不到自己的充值啦。情况很糟糕，但是！不用担心，我们有办法解决。<br>还记得上边提到的注销交易的方法吗？没错就是：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:transaction]</span><br></pre></td></tr></table></figure></p>
<p>当购买在苹果后台支付成功时，如果你的App没有调用这个方法，那么苹果就不会认为这次交易彻底成功，当你的App再次启动，并且设置了内购的监听时，监听方法<code>- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray&lt;SKPaymentTransaction *&gt; *)transactions</code>就会被调用，直到你调用了上面的方法，注销了这次交易，苹果才会认为这次交易彻底完成。<br>利用这个特性，我们可以将完成购买后注销方法放到我们向自家后台发送交易成功后调用。<br>讲到这里，关于内购的大坑我目前遇到的都已经解决啦，当然，你如果实际去操作，可能还会遇到各种各样的小坑，但是没关系，我相信你能够自己解决。。。所以，我就不说啦。<br>准备爬坑吧！少年！</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/blog/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

